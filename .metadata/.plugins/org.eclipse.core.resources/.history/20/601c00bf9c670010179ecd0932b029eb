/*
 * Application 1:
	-Đọc và trả về giá trị nhiệt độ chip qua ADC (mỗi 1 giây), hiện giá trị trên UART
	-Truyền tín hiệu ON LED  và OFF LED qua UART_interrupt để bật tắt led
 *
 */
#include "main.h"
#include <string.h>

#define ADC1_BASE_ADDR		0x40012000
#define RCC_BASE_ADDR		0x40023800
#define GPIOB_BASE_ADDR		0x40020400
#define USART1_BASE_ADDR	0X40011000
#define DMA2_BASE_ADDR		0x40026400
#define GPIOD_BASE_ADDR 	0x40020C00

void LedInit()
{
	uint32_t* RCC_AHB1ENR = (uint32_t*)(RCC_BASE_ADDR + 0x30);
	*RCC_AHB1ENR |= (1 << 3);			//Enable clock GPIOD

	uint32_t* GPIOD_MODER = (uint32_t*)(GPIOD_BASE_ADDR + 0x00);
	*GPIOD_MODER &= ~(0b11 << 24);
	*GPIOD_MODER |= (0b01 << 24);		// PD12: Output
}
void LedCtrl(int on_off)
{
	uint32_t* GPIOD_BSRR = (uint32_t*)(GPIOD_BASE_ADDR + 0x18);
    if(on_off == 1)
    {
        *GPIOD_BSRR = (1 << 12);         // PD12 ON
    }
    else
    {
        *GPIOD_BSRR = (1 << (12 + 16));  // PD12 OFF
    }
}

uint8_t uart_rxbuffer[1] = {0};
void DMA_init()
{
	// Enable clock DMA2
	uint32_t* RCC_AHB1ENR = (uint32_t*)(RCC_BASE_ADDR + 0x30);
	*RCC_AHB1ENR |= (1 << 22);

	// Tính offset stream2
	uint32_t* DMA_S2CR   = (uint32_t*)(DMA2_BASE_ADDR + 0x10 + 0x18 * 2);
	uint32_t* DMA_S2NDTR = (uint32_t*)(DMA2_BASE_ADDR + 0x14 + 0x18 * 2);
	uint32_t* DMA_S2PAR  = (uint32_t*)(DMA2_BASE_ADDR + 0x18 + 0x18 * 2);
	uint32_t* DMA_S2M0AR = (uint32_t*)(DMA2_BASE_ADDR + 0x1C + 0x18 * 2);

	*DMA_S2CR &= ~(1 << 0);        // Tắt DMA trước cấu hình
	*DMA_S2CR &= ~(0b11 << 6);     // Chọn Peripheral to Memory
	*DMA_S2CR |= (1 << 8);         // Circular mode
	*DMA_S2CR &= ~(1 << 9);        // Không tăng địa chỉ ngoại vi
	*DMA_S2CR |= (1 << 10);        // Tăng địa chỉ vùng nhớ (MINC)
	*DMA_S2CR &= ~(0b11 << 11);    // PSIZE = 8bit
	*DMA_S2CR &= ~(0b11 << 13);    // MSIZE = 8bit
	*DMA_S2CR |= (1 << 1);         // Bật ngắt hoàn tất truyền (TCIE)
	*DMA_S2CR &= ~(0b111 << 25);
	*DMA_S2CR |= (4 << 25);        // Chọn Channel 4

	*DMA_S2NDTR = 1;               // Số byte cần nhận
	*DMA_S2PAR = USART1_BASE_ADDR + 0x04;         // Địa chỉ thanh ghi DR của UART1
	*DMA_S2M0AR = (uint32_t)uart_rxbuffer;        // Địa chỉ buffer nhận

	*DMA_S2CR |= (1 << 0);         // Enable DMA Stream2

	// Enable interrupt DMA2_Stream2 (vị trí 58 → ISER1, bit 26)
	uint32_t* NVIC_ISER1 = (uint32_t*)(0xE000E100 + 0x04);
	*NVIC_ISER1 |= (1 << 26);
}

void UART_init()
{
	uint32_t* RCC_AHB1ENR = (uint32_t*)(RCC_BASE_ADDR + 0x30);
	*RCC_AHB1ENR |= (1 << 1);			//Enable clock GPIOB
	uint32_t* RCC_APB2ENR = (uint32_t*)(RCC_BASE_ADDR + 0x44);
	*RCC_APB2ENR |= (1 << 4);			//Enable clock USART1

	uint32_t* GPIOB_MODER = (uint32_t*)(GPIOB_BASE_ADDR + 0x00);
	uint32_t* GPIOB_AFRL = (uint32_t*)(GPIOB_BASE_ADDR + 0x20);

	*GPIOB_MODER &= ~(0b11 << (7 * 2));
	*GPIOB_MODER |=  (0b10 << (7 * 2));			// Alternate Function
	*GPIOB_AFRL  &= ~(0xF << (7 * 4));
	*GPIOB_AFRL  |=  (0x7 << (7 * 4));			// AF7 cho PB7

	*GPIOB_MODER &= ~(0b11 << (6 * 2));
	*GPIOB_MODER |=  (0b10 << (6 * 2));			// Alternate Function
	*GPIOB_AFRL  &= ~(0xF << (6 * 4));
	*GPIOB_AFRL  |=  (0x7 << (6 * 4));			// AF7 cho PB6


	//Cấu hình UART
	uint32_t* USART1_BRR = (uint32_t*)(USART1_BASE_ADDR + 0x08);
	*USART1_BRR &= ~(0xff << 0);
	*USART1_BRR |= (104 << 4) | (3 << 0);		//BAUDRATE = 9600 byte/s
												//DIV_Mantissa = 104
												//DIV_Fraction = 3
	uint32_t* USART1_CR1 = (uint32_t*)(USART1_BASE_ADDR + 0x0C);
	uint32_t* USART1_CR3 = (uint32_t*)(USART1_BASE_ADDR + 0x14);
	*USART1_CR1 &= ~(1 << 13);		//Disable UART
	*USART1_CR1 &= ~(1 << 15);		//Over sampling 16
	*USART1_CR1 &= ~(1 << 12);		//M=0 8 bit data
//	*USART1_CR1 |= (1 << 10);		//Enable parity
//	*USART1_CR1 |= (1 << 9);		//Odd parity
	*USART1_CR1 &= ~(1 << 10);
	*USART1_CR1 &= ~(1 << 9);
	*USART1_CR3 |= (1 << 6);		//Enable DMA
	*USART1_CR1 |= (1 << 2);		//Enable receive
	*USART1_CR1 |= (1 << 3);    	// Enable Transmit
	*USART1_CR1 |= (1 << 13);		//Enable UART

	// Bật interrupt cho vị trí số 37 (USART1) = ISER1, bit 5
	uint32_t* NVIC_ISER1 = (uint32_t*)(0xE000E100 + 0x04);
	*NVIC_ISER1 |= (1 << 5);
}

void UART_Transmit(uint8_t data)
{
	uint32_t* USART_DR= (uint32_t*)(USART1_BASE_ADDR + 0x04);
	uint32_t* USART_SR= (uint32_t*)(USART1_BASE_ADDR + 0x00);
	while((*USART_SR & (1 << 7))==0);
	*USART_DR = data;
	while((*USART_SR & (1 << 6))==0);
}
void Temp_sensor_init()
{
	uint32_t* RCC_APB2ENR = (uint32_t*)(RCC_BASE_ADDR + 0x44);
	*RCC_APB2ENR |= (1 << 8);				//Bật clock ADC

	uint32_t* ADC_CR1	= (uint32_t*)(ADC1_BASE_ADDR + 0x04);
	uint32_t* ADC_CR2	= (uint32_t*)(ADC1_BASE_ADDR + 0x08);
	uint32_t* ADC_JSQR	= (uint32_t*)(ADC1_BASE_ADDR + 0x38);
	uint32_t* ADC_CCR	= (uint32_t*)(ADC1_BASE_ADDR + 0x300 + 0x04);
	uint32_t* ADC_SMPR1	= (uint32_t*)(ADC1_BASE_ADDR + 0x0C);

	*ADC_JSQR	|= (16 << 15);				//1 input
	*ADC_CCR	|= (1 << 23);				//Bật temperature sensor
	*ADC_SMPR1	|= (0b110 << 18);			// 84 cycles
	*ADC_CR1	&= ~(0b11 << 24);			//12 bit phân giải
	*ADC_CR2	|= (1 << 0);				//Enable ADC
}

float Temp_sensor_read()
{
	uint32_t* ADC_CR2	= (uint32_t*)(ADC1_BASE_ADDR + 0x08);
	uint32_t* ADC_SR	= (uint32_t*)(ADC1_BASE_ADDR + 0x00);
	uint32_t* ADC_JDR1	= (uint32_t*)(ADC1_BASE_ADDR + 0x3C);

	*ADC_CR2 |= (1 << 22);					//Start ADC
	while (((*ADC_SR >> 2) &1) ==0);		//Chờ đo xong
	*ADC_SR &= ~(1 << 2);					//Xóa cờ đo

	uint16_t data_raw = *ADC_JDR1;			//Đọc thanh ghi JDR1
	float Vin = (data_raw * 3.0)/4095.0;	//tính điện áp đo được
	float temperature = ((Vin - 0.76) /0.0025) +25.0 ;		//Chuyển điện áp thành nhiệt độ
	return temperature;
}
float temp;
//void DMA2_Stream2_IRQHandler(void)
//{
//	uint32_t* LISR  = (uint32_t*)(DMA2_BASE_ADDR + 0x00);
//	uint32_t* LIFCR = (uint32_t*)(DMA2_BASE_ADDR + 0x08);
//
//	if (*LISR & (1 << 21)) // TCIF2
//	{
//		*LIFCR |= (1 << 21); // clear flag
//
//		if (uart_rxbuffer[0] == '0')
//		{
//			LedCtrl(0);
//			UART_Transmit(uart_rxbuffer[0]);
//		}
//		else if (uart_rxbuffer[0] == '1')
//		{
//			LedCtrl(1);
//			UART_Transmit(uart_rxbuffer[0]);
//		}
//	}
//}


int main()
{
	HAL_Init();
	Temp_sensor_init();
	LedInit();
	UART_init();
	DMA_init();
	while(1)
	{
		if (uart_rxbuffer[0] == '0')
		{
			LedCtrl(0);

		}
		else if (uart_rxbuffer[0] == '1')
		{
			LedCtrl(1);

		}

	}
}
