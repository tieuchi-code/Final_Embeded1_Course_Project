/*
 * Application 1:
	-ƒê·ªçc v√† tr·∫£ v·ªÅ gi√° tr·ªã nhi·ªát ƒë·ªô chip qua ADC (m·ªói 1 gi√¢y), hi·ªán gi√° tr·ªã tr√™n UART
	-Truy·ªÅn t√≠n hi·ªáu ON LED  v√† OFF LED qua UART_interrupt ƒë·ªÉ b·∫≠t t·∫Øt led
 *
 */
#include "main.h"
#include <string.h>

#define ADC1_BASE_ADDR		0x40012000
#define RCC_BASE_ADDR		0x40023800
#define GPIOB_BASE_ADDR		0x40020400
#define USART1_BASE_ADDR	0X40011000
#define DMA2_BASE_ADDR		0x40026400
#define GPIOD_BASE_ADDR 	0x40020C00


void LedInit()
{
	uint32_t* RCC_AHB1ENR = (uint32_t*)(RCC_BASE_ADDR + 0x30);
	*RCC_AHB1ENR |= (1 << 3);			//Enable clock GPIOD

	uint32_t* GPIOD_MODER = (uint32_t*)(GPIOD_BASE_ADDR + 0x00);
	*GPIOD_MODER &= ~(0b11 << 24);
	*GPIOD_MODER |= (0b01 << 24);		// PD12: Output
}
void LedCtrl(int on_off)
{
	uint32_t* GPIOD_BSRR = (uint32_t*)(GPIOD_BASE_ADDR + 0x18);
    if(on_off == 1)
    {
        *GPIOD_BSRR = (1 << 12);         // PD12 ON
    }
    else
    {
        *GPIOD_BSRR = (1 << (12 + 16));  // PD12 OFF
    }
}
char data[100];  //t·∫°o m·∫£ng ƒë·ªÉ c√°c k√Ω t·ª± d·ªØ li·ªáu nh·∫≠n ƒë∆∞·ª£c ghi l·∫ßn l∆∞·ª£t v√†o c√°c ph·∫ßn t·ª≠ m·∫£ng
int idx;	// t·∫°o bi·∫øn i ƒë·ªÉ l·∫•y th·ª© t·ª± c√°c ph·∫ßn t·ª≠ trong m·∫£ng
void UART_init()
{
//	uint32_t* RCC_AHB1ENR = (uint32_t*)(RCC_BASE_ADDR + 0x30);
//	*RCC_AHB1ENR |= (1 << 1);			//Enable clock GPIOB
//	uint32_t* RCC_APB2ENR = (uint32_t*)(RCC_BASE_ADDR + 0x44);
//	*RCC_APB2ENR |= (1 << 4);			//Enable clock USART1
//
//	uint32_t* GPIOB_MODER = (uint32_t*)(GPIOB_BASE_ADDR + 0x00);
//	uint32_t* GPIOB_AFRL = (uint32_t*)(GPIOB_BASE_ADDR + 0x20);
//
//	*GPIOB_MODER &= ~(0b11 << (7 * 2));
//	*GPIOB_MODER |=  (0b10 << (7 * 2));			// Alternate Function
//	*GPIOB_AFRL  &= ~(0xF << (7 * 4));
//	*GPIOB_AFRL  |=  (0x7 << (7 * 4));			// AF7 cho PB7
//
//	*GPIOB_MODER &= ~(0b11 << (6 * 2));
//	*GPIOB_MODER |=  (0b10 << (6 * 2));			// Alternate Function
//	*GPIOB_AFRL  &= ~(0xF << (6 * 4));
//	*GPIOB_AFRL  |=  (0x7 << (6 * 4));			// AF7 cho PB6
//
	// B·∫≠t clock GPIOA (thay v√¨ GPIOB)
	uint32_t* RCC_AHB1ENR = (uint32_t*)(RCC_BASE_ADDR + 0x30);
	*RCC_AHB1ENR |= (1 << 0);  // Enable clock GPIOA
	uint32_t* RCC_APB2ENR = (uint32_t*)(RCC_BASE_ADDR + 0x44);
	*RCC_APB2ENR |= (1 << 4);  // Enable clock USART1

	uint32_t* GPIOA_MODER = (uint32_t*)(0x40020000 + 0x00);     // GPIOA base
	uint32_t* GPIOA_AFRH  = (uint32_t*)(0x40020000 + 0x24);     // AFRH for PA9/PA10

	*GPIOA_MODER &= ~(0b11 << (9 * 2));
	*GPIOA_MODER |=  (0b10 << (9 * 2));   // PA9 = AF
	*GPIOA_AFRH  &= ~(0xF << ((9 - 8) * 4));
	*GPIOA_AFRH  |=  (0x7 << ((9 - 8) * 4));  // AF7 cho PA9

	*GPIOA_MODER &= ~(0b11 << (10 * 2));
	*GPIOA_MODER |=  (0b10 << (10 * 2));  // PA10 = AF
	*GPIOA_AFRH  &= ~(0xF << ((10 - 8) * 4));
	*GPIOA_AFRH  |=  (0x7 << ((10 - 8) * 4)); // AF7 cho PA10

	//C·∫•u h√¨nh UART
	uint32_t* USART1_BRR = (uint32_t*)(USART1_BASE_ADDR + 0x08);
	*USART1_BRR = (104 << 4) | 3;
//	*USART1_BRR &= ~(0xff << 0);
//	*USART1_BRR |= (104 << 4) | (3 << 0);		//BAUDRATE = 9600 byte/s
//												//DIV_Mantissa = 104
//												//DIV_Fraction = 3
	uint32_t* USART1_CR1 = (uint32_t*)(USART1_BASE_ADDR + 0x0C);
//	uint32_t* USART1_CR3 = (uint32_t*)(USART1_BASE_ADDR + 0x14);
	*USART1_CR1 &= ~(1 << 13);		//Disable UART
	*USART1_CR1 &= ~(1 << 15);		//Over sampling 16
	*USART1_CR1 &= ~(1 << 12);		//M=0 8 bit data
//	*USART1_CR1 |= (1 << 10);		//Enable parity
//	*USART1_CR1 |= (1 << 9);		//Odd parity
	*USART1_CR1 &= ~(1 << 10);
	*USART1_CR1 &= ~(1 << 9);
//	*USART1_CR3 |= (1 << 6);		//Enable DMA
//	*USART1_CR1 |= (1 << 6); 		// Enable Transmission Complete Interrupt
	*USART1_CR1 |= (1 << 5); 		//Enable interrupt when Receive register not empty
	*USART1_CR1 |= (1 << 2);		//Enable receive
	*USART1_CR1 |= (1 << 3);    	// Enable Transmit
	*USART1_CR1 |= (1 << 13);		//Enable UART

	// B·∫≠t interrupt cho v·ªã tr√≠ s·ªë 37 (USART1) = ISER1, bit 5
	uint32_t* NVIC_ISER1 = (uint32_t*)(0xE000E100 + 0x04);
	*NVIC_ISER1 |= (1 << 5);
}

void UART_Transmit(uint8_t data)
{
	uint32_t* USART_DR= (uint32_t*)(USART1_BASE_ADDR + 0x04);
	uint32_t* USART_SR= (uint32_t*)(USART1_BASE_ADDR + 0x00);
	while((*USART_SR & (1 << 7))==0);
	*USART_DR = data;
	while((*USART_SR & (1 << 6))==0);
}
char UART_recieve()
{
	uint32_t *UART_DR = (uint32_t*)(USART1_BASE_ADDR + 0x04);
//	uint32_t *UART_SR = (uint32_t*)(USART1_BASE_ADDR + 0x00);
	char data = *UART_DR;
	return data;
}
void UART_print_log(char *msg)
{
	int msg_len = strlen(msg);
	for( int i = 0 ; i < msg_len ; i++)
	{
		UART_Transmit((uint8_t)msg[i]);
	}
}
void USART1_IRQHandler(void)
{
	if (idx < sizeof(data) - 1)
		data[idx++] = UART_recieve();
	else
	{
		idx = 0;
		memset(data, 0, sizeof(data));  // üîÑ Reset buffer n·∫øu ƒë·∫ßy
	}

	if (strstr(data, "LED ON"))
	{
		LedCtrl(1);
		UART_print_log("ON ok\r\n");
		memset(data, 0, sizeof(data));
		idx = 0;
	}
	else if (strstr(data, "LED OFF"))
	{
		LedCtrl(0);
		UART_print_log("OFF ok\r\n");
		memset(data, 0, sizeof(data));
		idx = 0;
	}
}
void UART_send_number(int num)
{
    char buf[10];
    int i = 0;
    if (num == 0)
    {
        UART_Transmit('0');
        return;
    }

    if (num < 0)
    {
        UART_Transmit('-');
        num = -num;
    }

    while (num > 0)
    {
        buf[i++] = (num % 10) + '0';
        num /= 10;
    }

    // In ng∆∞·ª£c l·∫°i
    for (int j = i - 1; j >= 0; j--)
    {
        UART_Transmit(buf[j]);
    }
}
void UART_send_float(float value)
{
    int int_part = (int)value;  // Ph·∫ßn nguy√™n
    int frac_part = (int)((value - int_part) * 100);  // Ph·∫ßn th·∫≠p ph√¢n, gi·ªØ 2 s·ªë

    UART_send_number(int_part);
    UART_Transmit('.');
    if (frac_part < 10) UART_Transmit('0');  // In s·ªë 0 n·∫øu < 10
    UART_send_number(frac_part);
    UART_Transmit('\r');
    UART_Transmit('\n');
}

void Temp_sensor_init()
{
	uint32_t* RCC_APB2ENR = (uint32_t*)(RCC_BASE_ADDR + 0x44);
	*RCC_APB2ENR |= (1 << 8);				//B·∫≠t clock ADC

	uint32_t* ADC_CR1	= (uint32_t*)(ADC1_BASE_ADDR + 0x04);
	uint32_t* ADC_CR2	= (uint32_t*)(ADC1_BASE_ADDR + 0x08);
	uint32_t* ADC_JSQR	= (uint32_t*)(ADC1_BASE_ADDR + 0x38);
	uint32_t* ADC_CCR	= (uint32_t*)(ADC1_BASE_ADDR + 0x300 + 0x04);
	uint32_t* ADC_SMPR1	= (uint32_t*)(ADC1_BASE_ADDR + 0x0C);

	*ADC_JSQR	|= (16 << 15);				//1 input
	*ADC_CCR	|= (1 << 23);				//B·∫≠t temperature sensor
	*ADC_SMPR1	|= (0b110 << 18);			// 84 cycles
	*ADC_CR1	&= ~(0b11 << 24);			//12 bit ph√¢n gi·∫£i
	*ADC_CR2	|= (1 << 0);				//Enable ADC
}

float Temp_sensor_read()
{
	uint32_t* ADC_CR2	= (uint32_t*)(ADC1_BASE_ADDR + 0x08);
	uint32_t* ADC_SR	= (uint32_t*)(ADC1_BASE_ADDR + 0x00);
	uint32_t* ADC_JDR1	= (uint32_t*)(ADC1_BASE_ADDR + 0x3C);

	*ADC_CR2 |= (1 << 22);					//Start ADC
	while (((*ADC_SR >> 2) &1) ==0);		//Ch·ªù ƒëo xong
	*ADC_SR &= ~(1 << 2);					//X√≥a c·ªù ƒëo

	uint16_t data_raw = *ADC_JDR1;			//ƒê·ªçc thanh ghi JDR1
	float Vin = (data_raw * 3.0)/4095.0;	//t√≠nh ƒëi·ªán √°p ƒëo ƒë∆∞·ª£c
	float temperature = ((Vin - 0.76) /0.0025) +25.0 ;		//Chuy·ªÉn ƒëi·ªán √°p th√†nh nhi·ªát ƒë·ªô
	return temperature;
}
float temp;

int main()
{
    HAL_Init();
    Temp_sensor_init();
    LedInit();
    UART_init();
    while(1)
    {
    	temp = Temp_sensor_read();
    	UART_print_log("Temp: ");
    	UART_send_float(temp);
    	HAL_Delay(1200);

    }
}

