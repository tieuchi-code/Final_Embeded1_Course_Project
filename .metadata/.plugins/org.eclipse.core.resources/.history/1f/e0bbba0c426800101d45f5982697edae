/*
 * Application 2:
	-X√°c ƒë·ªãnh h∆∞·ªõng NEWS (m·ªói gi√¢y g·ª≠i gi√° tr·ªã v·ªÅ 1 l·∫ßn qua UART)
	-Ch·ª©a code update firmware cho app1
 */

#include "main.h"
#include <math.h>

#define GPIOD_BASE_ADDR 	0x40020C00
#define USART1_BASE_ADDR	0x40011000
#define RCC_BASE_ADDR      	0x40023800
#define GPIOB_BASE_ADDR	   	0x40020400
#define I2C1_BASE_ADDR     	0x40005400
#define USART2_BASE_ADDR	0x40004400

char data[100];  //t·∫°o m·∫£ng ƒë·ªÉ c√°c k√Ω t·ª± d·ªØ li·ªáu nh·∫≠n ƒë∆∞·ª£c ghi l·∫ßn l∆∞·ª£t v√†o c√°c ph·∫ßn t·ª≠ m·∫£ng
int idx;	// t·∫°o bi·∫øn i ƒë·ªÉ l·∫•y th·ª© t·ª± c√°c ph·∫ßn t·ª≠ trong m·∫£ng
void UART_init()
{
	uint32_t* RCC_AHB1ENR = (uint32_t*)(RCC_BASE_ADDR + 0x30);
	*RCC_AHB1ENR |= (1 << 0);			// Enable clock GPIOA

	uint32_t* RCC_APB1ENR = (uint32_t*)(RCC_BASE_ADDR + 0x40);
	*RCC_APB1ENR |= (1 << 17);			// Enable clock USART2

	uint32_t* GPIOA_MODER = (uint32_t*)(0x40020000 + 0x00);
	uint32_t* GPIOA_AFRL  = (uint32_t*)(0x40020000 + 0x20);	// AFRL v√¨ PA2/PA3 < 8

	*GPIOA_MODER &= ~(0b11 << (2 * 2));
	*GPIOA_MODER |=  (0b10 << (2 * 2));			// PA2: Alternate Function
	*GPIOA_AFRL  &= ~(0xF << (2 * 4));
	*GPIOA_AFRL  |=  (0x7 << (2 * 4));			// AF7 cho PA2

	*GPIOA_MODER &= ~(0b11 << (3 * 2));
	*GPIOA_MODER |=  (0b10 << (3 * 2));			// PA3: Alternate Function
	*GPIOA_AFRL  &= ~(0xF << (3 * 4));
	*GPIOA_AFRL  |=  (0x7 << (3 * 4));			// AF7 cho PA3

	uint32_t* USART2_BRR = (uint32_t*)(USART2_BASE_ADDR + 0x08);
	*USART2_BRR &= ~(0xFFFF);
	*USART2_BRR |= (104 << 4) | (3 << 0);	// Baudrate 9600

	uint32_t* USART2_CR1 = (uint32_t*)(USART2_BASE_ADDR + 0x0C);
	*USART2_CR1 &= ~(1 << 13);			// Disable UART
	*USART2_CR1 &= ~(1 << 15);			// Oversampling = 16
	*USART2_CR1 &= ~(1 << 12);			// 8-bit
	*USART2_CR1 &= ~(1 << 10);			// No parity
	*USART2_CR1 &= ~(1 << 9);
	*USART2_CR1 |= (1 << 5);			// RXNE interrupt
	*USART2_CR1 |= (1 << 2);			// Enable receive
	*USART2_CR1 |= (1 << 3);			// Enable transmit
	*USART2_CR1 |= (1 << 13);			// Enable UART

	uint32_t* NVIC_ISER1 = (uint32_t*)(0xE000E100 + 0x04);
	*NVIC_ISER1 |= (1 << 6);			// USART2 = position 38 = ISER1, bit 6
}
void UART_Transmit(uint8_t data)
{
	uint32_t* USART_DR= (uint32_t*)(USART2_BASE_ADDR + 0x04);
	uint32_t* USART_SR= (uint32_t*)(USART2_BASE_ADDR + 0x00);
	while((*USART_SR & (1 << 7)) == 0);
	*USART_DR = data;
	while((*USART_SR & (1 << 6)) == 0);
}

char UART_recieve()
{
	uint32_t *UART_DR = (uint32_t*)(USART2_BASE_ADDR + 0x04);
	return *UART_DR;
}

void UART_print_log(char *msg)
{
	int msg_len = strlen(msg);
	for( int i = 0 ; i < msg_len ; i++)
	{
		UART_Transmit((uint8_t)msg[i]);
	}
}
void USART2_IRQHandler(void)
{
	if (idx < sizeof(data) - 1)
		data[idx++] = UART_recieve();
	else
	{
		idx = 0;
		memset(data, 0, sizeof(data));  // üîÑ Reset buffer n·∫øu ƒë·∫ßy
	}

	if (strstr(data, "LED ON"))
	{
		LedCtrl(1);
		UART_print_log("ON ok\r\n");
		memset(data, 0, sizeof(data));
		idx = 0;
	}
	else if (strstr(data, "LED OFF"))
	{
		LedCtrl(0);
		UART_print_log("OFF ok\r\n");
		memset(data, 0, sizeof(data));
		idx = 0;
	}
}

void UART_send_number(int num)
{
    char buf[10];
    int i = 0;
    if (num == 0)
    {
        UART_Transmit('0');
        return;
    }

    if (num < 0)
    {
        UART_Transmit('-');
        num = -num;
    }

    while (num > 0)
    {
        buf[i++] = (num % 10) + '0';
        num /= 10;
    }

    // In ng∆∞·ª£c l·∫°i
    for (int j = i - 1; j >= 0; j--)
    {
        UART_Transmit(buf[j]);
    }
}
void UART_send_float(float value)
{
    int int_part = (int)value;  // Ph·∫ßn nguy√™n
    int frac_part = (int)((value - int_part) * 100);  // Ph·∫ßn th·∫≠p ph√¢n, gi·ªØ 2 s·ªë

    UART_send_number(int_part);
    UART_Transmit('.');
    if (frac_part < 10) UART_Transmit('0');  // In s·ªë 0 n·∫øu < 10
    UART_send_number(frac_part);
    UART_Transmit('\r');
    UART_Transmit('\n');
}

void I2C1_Master_Init() // PB6=SCL, PB9=SDA
{
    // Clock GPIOB + I2C1
    volatile uint32_t* RCC_AHB1ENR = (uint32_t*)(RCC_BASE_ADDR + 0x30);
    volatile uint32_t* RCC_APB1ENR = (uint32_t*)(RCC_BASE_ADDR + 0x40);
    *RCC_AHB1ENR |= (1 << 1);
    *RCC_APB1ENR |= (1 << 21);

    // C·∫•u h√¨nh ch√¢n PB6 + PB9
    volatile uint32_t* MODER   = (uint32_t*)(GPIOB_BASE_ADDR + 0x00);
    volatile uint32_t* OTYPER  = (uint32_t*)(GPIOB_BASE_ADDR + 0x04);
    volatile uint32_t* OSPEEDR = (uint32_t*)(GPIOB_BASE_ADDR + 0x08);
    volatile uint32_t* PUPDR   = (uint32_t*)(GPIOB_BASE_ADDR + 0x0C);
    volatile uint32_t* AFRL    = (uint32_t*)(GPIOB_BASE_ADDR + 0x20);
    volatile uint32_t* AFRH    = (uint32_t*)(GPIOB_BASE_ADDR + 0x24);

    // AF mode
    *MODER &= ~((0b11 << (6 * 2)) | (0b11 << (9 * 2)));
    *MODER |=  ((0b10 << (6 * 2)) | (0b10 << (9 * 2)));

    // Open-drain
    *OTYPER |= (1 << 6) | (1 << 9);

    // High speed
    *OSPEEDR &= ~((0b11 << (6 * 2)) | (0b11 << (9 * 2)));
    *OSPEEDR |=  ((0b11 << (6 * 2)) | (0b11 << (9 * 2)));

    // Pull-up
    *PUPDR &= ~((0b11 << (6 * 2)) | (0b11 << (9 * 2)));
    *PUPDR |=  ((0b01 << (6 * 2)) | (0b01 << (9 * 2)));

    // AF4 cho PB6 + PB9
    *AFRL &= ~(0xF << (6 * 4));
    *AFRL |=  (0x4 << (6 * 4));
    *AFRH &= ~(0xF << ((9 - 8) * 4));
    *AFRH |=  (0x4 << ((9 - 8) * 4));

    // C·∫•u h√¨nh I2C1
    volatile uint32_t* CR1   = (uint32_t*)(I2C1_BASE_ADDR + 0x00);
    volatile uint32_t* CR2   = (uint32_t*)(I2C1_BASE_ADDR + 0x04);
    volatile uint32_t* CCR   = (uint32_t*)(I2C1_BASE_ADDR + 0x1C);
    volatile uint32_t* TRISE = (uint32_t*)(I2C1_BASE_ADDR + 0x20);

    *CR1 &= ~(1 << 0);     // T·∫Øt I2C
    *CR2 = 16;             // Fpclk = 16MHz
    *CCR = 80;             // Speed 100kHz
    *TRISE = 17;           // TRISE = Fpclk / 1M + 1
    *CR1 |= (1 << 0);      // B·∫≠t I2C
}

void I2C_master_transmit_magnetometer_init()
{
    volatile uint32_t* CR1 = (uint32_t*)(I2C1_BASE_ADDR + 0x00);
    volatile uint32_t* SR1 = (uint32_t*)(I2C1_BASE_ADDR + 0x14);
    volatile uint32_t* SR2 = (uint32_t*)(I2C1_BASE_ADDR + 0x18);
    volatile uint32_t* DR  = (uint32_t*)(I2C1_BASE_ADDR + 0x10);

    *CR1 |= (1 << 8);                          // START
    while (((*SR1 >> 0) & 1) == 0);            // ƒê·ª£i SB = 1

    *DR = (0x1E << 1)|0;                       // G·ª≠i ƒë·ªãa ch·ªâ slave + Write
    while (((*SR1 >> 1) & 1) == 0);            // ADDR = 1
    (void)*SR2;

    while (((*SR1 >> 7) & 1) == 0);            // TxE = 1
    *DR = 0x60;                                // G·ª≠i ƒë·ªãa ch·ªâ thanh ghi

    while (((*SR1 >> 7) & 1) == 0);            // TxE = 1
    *DR = 0x00;                                // G·ª≠i d·ªØ li·ªáu

    while (((*SR1 >> 2) & 1) == 0);            // BTF = 1

    *CR1 |= (1 << 9);                          // STOP
}

uint8_t I2C1_Master_ReadRegister(uint8_t slave_addr, uint8_t reg_addr)
{
    volatile uint32_t* CR1 = (uint32_t*)(I2C1_BASE_ADDR + 0x00);
    volatile uint32_t* SR1 = (uint32_t*)(I2C1_BASE_ADDR + 0x14);
    volatile uint32_t* SR2 = (uint32_t*)(I2C1_BASE_ADDR + 0x18);
    volatile uint32_t* DR  = (uint32_t*)(I2C1_BASE_ADDR + 0x10);

    uint8_t data = 0;

    *CR1 |= (1 << 8);                          // START
    while (((*SR1 >> 0) & 1) == 0);            // SB

    *DR = (slave_addr << 1);                  // Addr + Write
    while (((*SR1 >> 1) & 1) == 0);            // ADDR
    (void)*SR2;

    while (((*SR1 >> 7) & 1) == 0);            // TxE
    *DR = reg_addr;                            // G·ª≠i ƒë·ªãa ch·ªâ thanh ghi

    while (((*SR1 >> 2) & 1) == 0);            // BTF

    *CR1 |= (1 << 8);                          // Re-START
    while (((*SR1 >> 0) & 1) == 0);            // SB

    *DR = (slave_addr << 1) | 1;              // Addr + Read
    while (((*SR1 >> 1) & 1) == 0);            // ADDR
    *CR1 &= ~(1 << 10);                        // NACK sau 1 byte
    (void)*SR2;

    *CR1 |= (1 << 9);                          // STOP

    while (((*SR1 >> 6) & 1) == 0);            // RxNE
    data = *DR;

    return data;
}
void LSM303AGR_Magnetometer_ReadXYZ(int16_t* x, int16_t* y, int16_t* z)
{
    uint8_t xl = I2C1_Master_ReadRegister(0x1E, 0x68);
    uint8_t xh = I2C1_Master_ReadRegister(0x1E, 0x69);
    uint8_t yl = I2C1_Master_ReadRegister(0x1E, 0x6A);
    uint8_t yh = I2C1_Master_ReadRegister(0x1E, 0x6B);
    uint8_t zl = I2C1_Master_ReadRegister(0x1E, 0x6C);
    uint8_t zh = I2C1_Master_ReadRegister(0x1E, 0x6D);

    *x = (int16_t)((xh << 8) | xl);
    *y = (int16_t)((yh << 8) | yl);
    *z = (int16_t)((zh << 8) | zl);
}
int16_t mx, my, mz;
float heading;

int main()
{
    HAL_Init();
    HAL_Delay(20);

    I2C1_Master_Init();                        // Kh·ªüi t·∫°o I2C
    I2C_master_transmit_magnetometer_init();   // B·∫≠t ch·∫ø ƒë·ªô continuous mode cho magnetometer

    while (1)
    {
        LSM303AGR_Magnetometer_ReadXYZ(&mx, &my, &mz);  // ƒê·ªçc d·ªØ li·ªáu t·ª´ c·∫£m bi·∫øn

        float offset = -12.0f;  // V√≠ d·ª• l·ªách 15 ƒë·ªô so v·ªõi B·∫Øc th·ª±c t·∫ø

        heading = atan2f((float)my, (float)mx) * 180.0f / M_PI;
        heading = -heading;
        heading += offset;

        if (heading < 0.0f) heading += 360.0f;
        if (heading >= 360.0f) heading -= 360.0f;
    	UART_print_log("N");
    	UART_send_float(heading);
        HAL_Delay(100);
    }
}
