/*
 * Application 2:
	-Xác định hướng NEWS (mỗi giây gửi giá trị về 1 lần qua UART)
	-Chứa code update firmware cho app1
 */

#include "main.h"
#include <math.h>

#define GPIOD_BASE_ADDR 	0x40020C00
#define USART1_BASE_ADDR	0x40011000
#define RCC_BASE_ADDR      	0x40023800
#define GPIOB_BASE_ADDR	   	0x40020400
#define I2C1_BASE_ADDR     	0x40005400


void I2C1_Master_Init() // PB6=SCL, PB9=SDA
{
    // Clock GPIOB + I2C1
    volatile uint32_t* RCC_AHB1ENR = (uint32_t*)(RCC_BASE_ADDR + 0x30);
    volatile uint32_t* RCC_APB1ENR = (uint32_t*)(RCC_BASE_ADDR + 0x40);
    *RCC_AHB1ENR |= (1 << 1);
    *RCC_APB1ENR |= (1 << 21);

    // Cấu hình chân PB6 + PB9
    volatile uint32_t* MODER   = (uint32_t*)(GPIOB_BASE_ADDR + 0x00);
    volatile uint32_t* OTYPER  = (uint32_t*)(GPIOB_BASE_ADDR + 0x04);
    volatile uint32_t* OSPEEDR = (uint32_t*)(GPIOB_BASE_ADDR + 0x08);
    volatile uint32_t* PUPDR   = (uint32_t*)(GPIOB_BASE_ADDR + 0x0C);
    volatile uint32_t* AFRL    = (uint32_t*)(GPIOB_BASE_ADDR + 0x20);
    volatile uint32_t* AFRH    = (uint32_t*)(GPIOB_BASE_ADDR + 0x24);

    // AF mode
    *MODER &= ~((0b11 << (6 * 2)) | (0b11 << (9 * 2)));
    *MODER |=  ((0b10 << (6 * 2)) | (0b10 << (9 * 2)));

    // Open-drain
    *OTYPER |= (1 << 6) | (1 << 9);

    // High speed
    *OSPEEDR &= ~((0b11 << (6 * 2)) | (0b11 << (9 * 2)));
    *OSPEEDR |=  ((0b11 << (6 * 2)) | (0b11 << (9 * 2)));

    // Pull-up
    *PUPDR &= ~((0b11 << (6 * 2)) | (0b11 << (9 * 2)));
    *PUPDR |=  ((0b01 << (6 * 2)) | (0b01 << (9 * 2)));

    // AF4 cho PB6 + PB9
    *AFRL &= ~(0xF << (6 * 4));
    *AFRL |=  (0x4 << (6 * 4));
    *AFRH &= ~(0xF << ((9 - 8) * 4));
    *AFRH |=  (0x4 << ((9 - 8) * 4));

    // Cấu hình I2C1
    volatile uint32_t* CR1   = (uint32_t*)(I2C1_BASE_ADDR + 0x00);
    volatile uint32_t* CR2   = (uint32_t*)(I2C1_BASE_ADDR + 0x04);
    volatile uint32_t* CCR   = (uint32_t*)(I2C1_BASE_ADDR + 0x1C);
    volatile uint32_t* TRISE = (uint32_t*)(I2C1_BASE_ADDR + 0x20);

    *CR1 &= ~(1 << 0);     // Tắt I2C
    *CR2 = 16;             // Fpclk = 16MHz
    *CCR = 80;             // Speed 100kHz
    *TRISE = 17;           // TRISE = Fpclk / 1M + 1
    *CR1 |= (1 << 0);      // Bật I2C
}

void I2C_master_transmit_magnetometer_init()
{
    volatile uint32_t* CR1 = (uint32_t*)(I2C1_BASE_ADDR + 0x00);
    volatile uint32_t* SR1 = (uint32_t*)(I2C1_BASE_ADDR + 0x14);
    volatile uint32_t* SR2 = (uint32_t*)(I2C1_BASE_ADDR + 0x18);
    volatile uint32_t* DR  = (uint32_t*)(I2C1_BASE_ADDR + 0x10);

    *CR1 |= (1 << 8);                          // START
    while (((*SR1 >> 0) & 1) == 0);            // Đợi SB = 1

    *DR = (0x1E << 1)|0;                       // Gửi địa chỉ slave + Write
    while (((*SR1 >> 1) & 1) == 0);            // ADDR = 1
    (void)*SR2;

    while (((*SR1 >> 7) & 1) == 0);            // TxE = 1
    *DR = 0x60;                                // Gửi địa chỉ thanh ghi

    while (((*SR1 >> 7) & 1) == 0);            // TxE = 1
    *DR = 0x00;                                // Gửi dữ liệu

    while (((*SR1 >> 2) & 1) == 0);            // BTF = 1

    *CR1 |= (1 << 9);                          // STOP
}

uint8_t I2C1_Master_ReadRegister(uint8_t slave_addr, uint8_t reg_addr)
{
    volatile uint32_t* CR1 = (uint32_t*)(I2C1_BASE_ADDR + 0x00);
    volatile uint32_t* SR1 = (uint32_t*)(I2C1_BASE_ADDR + 0x14);
    volatile uint32_t* SR2 = (uint32_t*)(I2C1_BASE_ADDR + 0x18);
    volatile uint32_t* DR  = (uint32_t*)(I2C1_BASE_ADDR + 0x10);

    uint8_t data = 0;

    *CR1 |= (1 << 8);                          // START
    while (((*SR1 >> 0) & 1) == 0);            // SB

    *DR = (slave_addr << 1);                  // Addr + Write
    while (((*SR1 >> 1) & 1) == 0);            // ADDR
    (void)*SR2;

    while (((*SR1 >> 7) & 1) == 0);            // TxE
    *DR = reg_addr;                            // Gửi địa chỉ thanh ghi

    while (((*SR1 >> 2) & 1) == 0);            // BTF

    *CR1 |= (1 << 8);                          // Re-START
    while (((*SR1 >> 0) & 1) == 0);            // SB

    *DR = (slave_addr << 1) | 1;              // Addr + Read
    while (((*SR1 >> 1) & 1) == 0);            // ADDR
    *CR1 &= ~(1 << 10);                        // NACK sau 1 byte
    (void)*SR2;

    *CR1 |= (1 << 9);                          // STOP

    while (((*SR1 >> 6) & 1) == 0);            // RxNE
    data = *DR;

    return data;
}
void LSM303AGR_Magnetometer_ReadXYZ(int16_t* x, int16_t* y, int16_t* z)
{
    uint8_t xl = I2C1_Master_ReadRegister(0x1E, 0x68);
    uint8_t xh = I2C1_Master_ReadRegister(0x1E, 0x69);
    uint8_t yl = I2C1_Master_ReadRegister(0x1E, 0x6A);
    uint8_t yh = I2C1_Master_ReadRegister(0x1E, 0x6B);
    uint8_t zl = I2C1_Master_ReadRegister(0x1E, 0x6C);
    uint8_t zh = I2C1_Master_ReadRegister(0x1E, 0x6D);

    *x = (int16_t)((xh << 8) | xl);
    *y = (int16_t)((yh << 8) | yl);
    *z = (int16_t)((zh << 8) | zl);
}
int16_t mx, my, mz;
float heading;

int main()
{
    HAL_Init();
    HAL_Delay(20);

    I2C1_Master_Init();                        // Khởi tạo I2C
    I2C_master_transmit_magnetometer_init();   // Bật chế độ continuous mode cho magnetometer

    while (1)
    {
        LSM303AGR_Magnetometer_ReadXYZ(&mx, &my, &mz);  // Đọc dữ liệu từ cảm biến

        heading = atan2f((float)my, (float)mx) * 180.0f / M_PI;
        if (heading < 0) heading += 360.0f;             // Đưa về [0 - 360] độ

        HAL_Delay(100);
    }
}
